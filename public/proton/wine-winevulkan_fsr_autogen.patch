From adf6eb9f73589cf0d31df8e26957bf1ac92918bc Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 23 Jul 2022 13:50:41 +0300
Subject: [PATCH] FSR autogen over some random fsr patch

---
 dlls/winex11.drv/fs.c | 277 ++++++++++++++++++++++++++++++++++++++----
 1 file changed, 255 insertions(+), 22 deletions(-)

diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
index 981affb3ef4..74394c261d9 100644
--- a/dlls/winex11.drv/fs.c
+++ b/dlls/winex11.drv/fs.c
@@ -59,46 +59,115 @@ struct fs_monitor_size
     DWORD height;
 };
 
+/* Some games have a limit on the number of entries allowed in the resolution list, 
+for example, Elden Ring's limit is 26. Therefore we cannot add all of the FSR 
+resolutions to the list without hitting the limit, which causes missing resolutions
+within the game's resolution list. You can use WINE_FULLSCREEN_FAKE_CURRENT_RES to 
+set the resolution used to scale up from. 
+
+Example: 
+Your monitor is 3440x1440
+You want to use FSR to scale up using ""Ultra Quality" FSR mode.
+
+You use:
+
+WINE_FULLSCREEN_FAKE_CURRENT_RES=2646x1108
+
+This allows you to use the custom resolution that is not in the games fullscreen
+resolution list to scale up.
+
+Below is a table of FSR values allowed that are not part of the fullscreen
+resolution list:
+
+    32:9 (5120x1440) -- Samsung Neo G9:
+    {2560, 720},  // 32:9 - 'FSR 32:9 Performance'
+    {3012, 847},  // 32:9 - 'FSR 32:9 Balanced'
+    {3413, 960},  // 32:9 - 'FSR 32:9 Quality'
+    {3938, 1108}, // 32:9 - 'FSR 32:9 Ultra Quality'
+
+    4K:
+    {1920, 1080}, // 16:9 - 'FSR 2160p Performance'
+    {2259, 1270}, // 16:9 - 'FSR 2160p Balanced'
+    {2560, 1440}, // 16:9 - 'FSR 2160p Quality'
+    {2954, 1662}, // 16:9 - 'FSR 2160p Ultra Quality'
+
+    Ultra-wide:
+    {1720, 720},  // 21:9 - 'FSR ultra-wide Performance'
+    {2024, 847},  // 21:9 - 'FSR ultra-wide Balanced'
+    {2293, 960},  // 21:9 - 'FSR ultra-wide Quality'
+    {2646, 1108}, // 21:9 - 'FSR ultra-wide Ultra Quality'
+
+    2K:
+    {1280, 720},  // 16:9 - 'FSR 1440p Performance'
+    {1506, 847},  // 16:9 - 'FSR 1440p Balanced'
+    {1706, 960},  // 16:9 - 'FSR 1440p Quality'
+    {1970, 1108}, // 16:9 - 'FSR 1440p Ultra Quality'
+
+    1080p:
+    {960, 640},   // 16:9 - 'FSR 1080p Performance'
+    {1129, 635},  // 16:9 - 'FSR 1080p Balanced'
+    {1280, 720},  // 16:9 - 'FSR 1080p Quality'
+    {1477, 831},  // 16:9 - 'FSR 1080p Ultra Quality'
+
+The formula for FSR resolutions is as follows:
+
+    Ultra Quality — 1.3x scaling
+    Quality — 1.5x scaling
+    Balanced — 1.7x scaling 
+    Performance — 2x scaling
+
+*/
+
 /* A table of resolutions some games expect but host system may not report */
-static struct fs_monitor_size fs_monitor_sizes[] =
+static struct fs_monitor_size fs_monitor_sizes_base[] =
 {
     {640, 480},   /*  4:3 */
     {800, 600},   /*  4:3 */
     {1024, 768},  /*  4:3 */
     {1600, 1200}, /*  4:3 */
-    {960, 540},   /* 16:9 - 'FSR 1080p Performance' */
-    {1130, 635},  /* 16:9 - 'FSR 1080p Balanced' */
-    {1280, 720},  /* 16:9 - 'FSR 1440p Performance, 1080p Quality' */
-    {1477, 831},  /* 16:9 - 'FSR 1080p Ultra Quality' */
-    {1506, 847},  /* 16:9 - 'FSR 1440p Balanced' */
+    {960, 540},   /* 16:9 */
+    {1280, 720},  /* 16:9 */
     {1600, 900},  /* 16:9 */
-    {1706, 960},  /* 16:9 - 'FSR 1440p Quality' */
-    {1920, 1080}, /* 16:9 - 'FSR 2160p Performance' */
-    {1970, 1108}, /* 16:9 - 'FSR 1440p Ultra Quality' */
-    {2259, 1270}, /* 16:9 - 'FSR 2160p Balanced' */
-    {2560, 1440}, /* 16:9 - 'FSR 2160p Quality' */
-    {2304, 1296}, /* 16:9 */
+    {1920, 1080}, /* 16:9 */
+    {2560, 1440}, /* 16:9 */
     {2048, 1152}, /* 16:9 */
-    {2880, 1620}, /* 16:9 */
-    {2954, 1662}, /* 16:9 - 'FSR 2160p Ultra Quality' */
-    {3200, 1800}, /* 16:9 */
     {1440, 900},  /*  8:5 */
     {1680, 1050}, /*  8:5 */
     {1920, 1200}, /*  8:5 */
-    {2560, 1600}, /*  8:5 */
     {1440, 960},  /*  3:2 */
     {1920, 1280}, /*  3:2 */
+    {2560, 1080}, /* 21:9 ultra-wide */
     {1920, 800},  /* 12:5 */
     {3840, 1600}, /* 12:5 */
-    {1720, 720}, /* 21:9 - 'FSR ultra-wide Performance' */
-    {2024, 847}, /* 21:9 - 'FSR ultra-wide Balanced' */
-    {2293, 960}, /* 21:9 - 'FSR ultra-wide Quality' */
     {2560, 1080}, /* 21:9 ultra-wide */
-    {2646, 1108}, /* 21:9 - 'FSR ultra-wide Ultra Quality' */
     {3440, 1440}, /* 21:9 ultra-wide */
     {1280, 1024}, /*  5:4 */
 };
 
+/* Dynamically assigned FSR resolutions */
+static struct fs_monitor_size fs_monitor_sizes_fsr[] =
+{
+    {0, 0}, /* FSR Performance */
+    {0, 0}, /* FSR Balanced */
+    {0, 0}, /* FSR Quality */
+    {0, 0}, /* FSR Ultra Quality */
+};
+
+/* The order should be in sync with the values in 'fs_hack_is_fsr_single_mode'*/
+static float fsr_ratios[] = {
+    2.0f, /* FSR Performance */
+    1.7f, /* FSR Balanced */
+    1.5f, /* FSR Quality */
+    1.3f, /* FSR Ultra Quality */
+};
+
+/* Fake resolution container */
+static struct fs_monitor_size fsr_custom_size = {0, 0};
+
+struct fs_monitor_size *fs_monitor_sizes = NULL;
+UINT fs_monitor_sizes_count = 0;
+
+
 /* A fake monitor for the fullscreen hack */
 struct fs_monitor
 {
@@ -174,6 +243,55 @@ static void add_fs_mode(struct fs_monitor *fs_monitor, DWORD depth, DWORD width,
     mode->dmDisplayFrequency = frequency;
 }
 
+BOOL fs_hack_is_fsr_single_mode(UINT *mode)
+{
+    const char *e;
+
+    e = getenv("WINE_FULLSCREEN_FSR_MODE");
+    if (e)
+    {
+        /* If empty or zero don't apply a mode */
+        if (*e == '\0' || *e == '0')
+            return FALSE;
+        /* The 'mode' values should be in sync with the order in 'fsr_ratios' */
+        if (!strcmp(e, "Ultra") || !strcmp(e, "ultra"))
+            *mode = 3;
+        else if (!strcmp(e, "Quality") || !strcmp(e, "quality"))
+            *mode = 2;
+        else if (!strcmp(e, "Balanced") || !strcmp(e, "balanced"))
+            *mode = 1;
+        else if (!strcmp(e, "Performance") || !strcmp(e, "performance"))
+            *mode = 0;
+        /* If the user mistyped the mode, return 'balanced' */
+        else
+            *mode = 1;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+BOOL fs_hack_is_fsr_custom_mode(void)
+{
+    DWORD width, height;
+    const char *e;
+
+    width = 0;
+    height = 0;
+    e = getenv("WINE_FULLSCREEN_FSR_CUSTOM_MODE");
+    if (e)
+    {
+        const int n = sscanf(e, "%dx%d", &width, &height);
+        if (n==2)
+        {
+            fsr_custom_size.width = width;
+            fsr_custom_size.height = height;
+            TRACE("found custom resolution: %dx%d\n", fsr_custom_size.width, fsr_custom_size.height);
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
 static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
 {
     DEVMODEW *real_modes, *real_mode, current_mode;
@@ -183,6 +301,10 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
     ULONG offset;
     UINT i, j;
 
+    UINT fsr_mode;
+    float sharpness, real_w_ratio, h_ratio, h_factor;
+    BOOL is_fsr, is_fsr_single_mode, is_fsr_custom_mode;
+
     if (!real_settings_handler.get_id(fs_monitor->user_mode.dmDeviceName, &real_id))
         return FALSE;
 
@@ -192,10 +314,110 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
     /* Fullscreen hack doesn't support changing display orientations */
     if (!real_settings_handler.get_modes(real_id, 0, &real_modes, &real_mode_count))
         return FALSE;
+    
+    is_fsr = fs_hack_is_fsr(&sharpness);
+    is_fsr_single_mode = FALSE;
+    is_fsr_custom_mode = FALSE;
+
+    if (fs_monitor_sizes)
+        heap_free(fs_monitor_sizes);
+    fs_monitor_sizes = NULL;
+    fs_monitor_sizes_count = 0;
+    if (!(fs_monitor_sizes = heap_alloc(sizeof(fs_monitor_sizes_base) + sizeof(fs_monitor_sizes_fsr) + sizeof(fsr_custom_size))))
+        return FALSE;
+
+    /* Copy the default list */
+    memcpy(fs_monitor_sizes+fs_monitor_sizes_count, fs_monitor_sizes_base, sizeof(fs_monitor_sizes_base));
+    fs_monitor_sizes_count += ARRAY_SIZE(fs_monitor_sizes_base);
+
+    /* If FSR is enabled, generate and add FSR resolutions */
+    if (is_fsr)
+    {
+        if (current_mode.dmPelsWidth / 16.0f == current_mode.dmPelsHeight / 9.0f)
+        {
+            /* 16:9 resolutions */
+            h_ratio = 9.0f;
+        }
+        else if ((DWORD)(current_mode.dmPelsWidth / 210.0f) == (DWORD)(current_mode.dmPelsHeight / 90.0f))
+        {
+            /* 21:9 ultra-wide resolutions */
+            h_ratio = 9.0f;
+        }
+        else if (current_mode.dmPelsWidth / 32.0f == current_mode.dmPelsHeight / 9.0f)
+        {
+            /* 32:9 "duper-ultra-wide" resolutions */
+            h_ratio = 9.0f;
+        }
+        else if (current_mode.dmPelsWidth / 8.0f == current_mode.dmPelsHeight / 5.0f)
+        {
+            /* 16:10 resolutions */
+            h_ratio = 10.0f;
+        }
+        else if (current_mode.dmPelsWidth / 12.0f == current_mode.dmPelsHeight / 5.0f)
+        {
+            /* 24:10 resolutions */
+            h_ratio = 10.0f;
+        }
+        else
+        {
+            /* In case of unknown ratio, naively create FSR resolutions */
+            h_ratio = 1.0f;
+        }
+
+        /* All inconsistent resolutions have correct height ratio, so compute the width ratio */
+        real_w_ratio = current_mode.dmPelsWidth / (current_mode.dmPelsHeight / h_ratio);
+        for (i = 0; i < ARRAY_SIZE(fs_monitor_sizes_fsr); ++i)
+        {
+            if (h_ratio == 1.0f)
+            {
+                /* Naive generation (matches AMD mode documentation but not sample code) */
+                /* AMD's sample rounds down, which doesn't match their published list of resolutions */
+                fs_monitor_sizes_fsr[i].width = (DWORD)(current_mode.dmPelsWidth / fsr_ratios[i] + 0.5f);
+                fs_monitor_sizes_fsr[i].height = (DWORD)(current_mode.dmPelsHeight / fsr_ratios[i] + 0.5f);
+            }
+            else
+            {
+                /* Round to nearest integer (our way) */
+                h_factor = (DWORD)((current_mode.dmPelsHeight / h_ratio) / fsr_ratios[i] + 0.5f);
+                fs_monitor_sizes_fsr[i].width = (DWORD)(real_w_ratio * h_factor + 0.5f);
+                fs_monitor_sizes_fsr[i].height = (DWORD)(h_ratio * h_factor + 0.5f);
+            }
+            TRACE("created fsr resolution: %dx%d, ratio: %1.1f\n",
+                  fs_monitor_sizes_fsr[i].width,
+                  fs_monitor_sizes_fsr[i].height,
+                  fsr_ratios[i]);
+        }
+
+        is_fsr_single_mode = fs_hack_is_fsr_single_mode(&fsr_mode);
+        /* If the user requested a single mode, only add that to the list */
+        if (is_fsr_single_mode)
+        {
+            memcpy(fs_monitor_sizes+fs_monitor_sizes_count, &fs_monitor_sizes_fsr[fsr_mode], sizeof(fs_monitor_sizes_fsr[fsr_mode]));
+            fs_monitor_sizes_count += 1;
+            /* Also place it in the custom resolution container, so we can limit resolutions later on */
+            fsr_custom_size.width = fs_monitor_sizes_fsr[fsr_mode].width;
+            fsr_custom_size.height = fs_monitor_sizes_fsr[fsr_mode].height;
+        }
+        /* If a single mode was not specified, add all FSR resolutions */
+        else
+        {
+            memcpy(fs_monitor_sizes+fs_monitor_sizes_count, fs_monitor_sizes_fsr, sizeof(fs_monitor_sizes_fsr));
+            fs_monitor_sizes_count += ARRAY_SIZE(fs_monitor_sizes_fsr);
+        }
+
+        /* Add the custom resolution to the list */
+        is_fsr_custom_mode = fs_hack_is_fsr_custom_mode();
+        if (is_fsr_custom_mode)
+        {
+            memcpy(fs_monitor_sizes+fs_monitor_sizes_count, &fsr_custom_size, sizeof(fsr_custom_size));
+            fs_monitor_sizes_count += 1;
+            TRACE("added custom resolution: %dx%d\n", fsr_custom_size.width, fsr_custom_size.height);
+        }
+    }
 
     fs_monitor->mode_count = 0;
     fs_monitor->unique_resolutions = 0;
-    fs_monitor->modes = heap_calloc(ARRAY_SIZE(fs_monitor_sizes) * DEPTH_COUNT + real_mode_count,
+    fs_monitor->modes = heap_calloc(fs_monitor_sizes_count * DEPTH_COUNT + real_mode_count,
                                     sizeof(*fs_monitor->modes));
     if (!fs_monitor->modes)
     {
@@ -209,7 +431,7 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
                 current_mode.u1.s2.dmDisplayOrientation);
 
     /* Linux reports far fewer resolutions than Windows. Add modes that some games may expect. */
-    for (i = 0; i < ARRAY_SIZE(fs_monitor_sizes); ++i)
+    for (i = 0; i < fs_monitor_sizes_count; ++i)
     {
         if (current_mode.u1.s2.dmDisplayOrientation == DMDO_DEFAULT ||
             current_mode.u1.s2.dmDisplayOrientation == DMDO_180)
@@ -227,6 +449,11 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
         if (width > current_mode.dmPelsWidth || height > current_mode.dmPelsHeight)
             continue;
 
+        /* Don't report modes that are larger than the requested fsr mode or the custom mode */
+        if(is_fsr && (is_fsr_custom_mode || is_fsr_single_mode))
+            if (width > fsr_custom_size.width || height > fsr_custom_size.height)
+                continue;
+
         for (j = 0; j < DEPTH_COUNT; ++j)
             add_fs_mode(fs_monitor, depths[j], width, height, 60,
                         current_mode.u1.s2.dmDisplayOrientation);
@@ -242,6 +469,12 @@ static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
             real_mode->dmPelsHeight > current_mode.dmPelsHeight)
             continue;
 
+        /* Don't report modes that are larger than the requested fsr mode or the custom mode */
+        if(is_fsr && (is_fsr_custom_mode || is_fsr_single_mode))
+            if (real_mode->dmPelsWidth > fsr_custom_size.width ||
+                real_mode->dmPelsHeight > fsr_custom_size.height)
+                continue;
+
         add_fs_mode(fs_monitor, real_mode->dmBitsPerPel, real_mode->dmPelsWidth,
                     real_mode->dmPelsHeight, real_mode->dmDisplayFrequency,
                     real_mode->u1.s2.dmDisplayOrientation);
-- 
2.37.1

